# üí´ About Me:
üî≠ I‚Äôm currently learning on padang university <br>üå± I‚Äôm currently learning c Language<br>üí¨ Ask me about how to know if a program can work and the results of the program can be implemented into the world of work<br>‚ö° Fun fact I like simple and structured learning


## üåê Socials:
[![Behance](https://img.shields.io/badge/Behance-1769ff?logo=behance&logoColor=white)](https://behance.net/Wahyu Abdil Afif) [![Facebook](https://img.shields.io/badge/Facebook-%231877F2.svg?logo=Facebook&logoColor=white)](https://facebook.com/Wahyu Abdil Afif) [![Instagram](https://img.shields.io/badge/Instagram-%23E4405F.svg?logo=Instagram&logoColor=white)](https://instagram.com/whyabdlafif19) [![TikTok](https://img.shields.io/badge/TikTok-%23000000.svg?logo=TikTok&logoColor=white)](https://tiktok.com/@@whyabdlafif19) 

# üíª Tech Stack:
![C](https://img.shields.io/badge/c-%2300599C.svg?style=flat-square&logo=c&logoColor=white) ![C++](https://img.shields.io/badge/c++-%2300599C.svg?style=flat-square&logo=c%2B%2B&logoColor=white) ![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=flat-square&logo=openjdk&logoColor=white) ![HTML5](https://img.shields.io/badge/html5-%23E34F26.svg?style=flat-square&logo=html5&logoColor=white) ![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=flat-square&logo=javascript&logoColor=%23F7DF1E) ![Python](https://img.shields.io/badge/python-3670A0?style=flat-square&logo=python&logoColor=ffdd54) ![Apache](https://img.shields.io/badge/apache-%23D42029.svg?style=flat-square&logo=apache&logoColor=white) ![MySQL](https://img.shields.io/badge/mysql-%2300000f.svg?style=flat-square&logo=mysql&logoColor=white) ![MongoDB](https://img.shields.io/badge/MongoDB-%234ea94b.svg?style=flat-square&logo=mongodb&logoColor=white) ![Adobe](https://img.shields.io/badge/adobe-%23FF0000.svg?style=flat-square&logo=adobe&logoColor=white) ![Canva](https://img.shields.io/badge/Canva-%2300C4CC.svg?style=flat-square&logo=Canva&logoColor=white)
# üìä GitHub Stats:
![](https://github-readme-stats.vercel.app/api?username=wahyuafif19&theme=dark&hide_border=false&include_all_commits=false&count_private=false)<br/>
![](https://github-readme-streak-stats.herokuapp.com/?user=wahyuafif19&theme=dark&hide_border=false)<br/>
![](https://github-readme-stats.vercel.app/api/top-langs/?username=wahyuafif19&theme=dark&hide_border=false&include_all_commits=false&count_private=false&layout=compact)

---
[![](https://visitcount.itsvg.in/api?id=wahyuafif19&icon=0&color=3)](https://visitcount.itsvg.in)

<!-- Proudly created with GPRM ( https://gprm.itsvg.in ) -->


# Kesimpulan Praktikum Struktur Data 

## Daftar Isi

- [JOBSHEET 1 Pengenalan Struktur Data](#JOBSHEET-1-Pengenalan-Struktur-Data)
- [JOBSHEET 2 Array, Pointer dan Stuct](#JOBSHEET-2-Array-Pointer-dan-Stuct)
- [JOBSHEET 3 Single Linked List](#JOBSHEET-3-Single-Linked-List)
- [JOBSHEET 4 Doubly Linked List](#JOBSHEET-4-Doubly-Linked-List)
- [JOBSHEET 5 Circular Linked List](#JOBSHEET-5-Circular-Linked-List)
- [JOBSHEET 6 Stack](#JOBSHEET-6-Stack)
- [JOBSHEET 7 Queue](#JOBSHEET-7-Queue)
- [JOBSHEET 8 Bubble and Insertion Sort](#JOBSHEET-8-Bubble-and-Insertion-Sort)
- [JOBSHEET 9 Selection and Merge Sort](#JOBSHEET-9-Selection-and-Merge-Sort)
- [JOBSHEET 10 Shell and Quick Sort](#JOBSHEET-10-Shell-and-Quick-Sort)
- [JOBSHEET 11 Linear and Binary Search](#JOBSHEET-11-Linear-and-Binary-Search)
- [JOBSHEET 12 Tree](#JOBSHEET-12-Tree)
- [JOBSHEET 13 Graphs](#JOBSHEET-13-Graphs)


## JOBSHEET 1 Pengenalan Struktur Data

Struktur data adalah cara untuk mengorganisasi dan menyimpan data agar dapat diakses dan dimodifikasi secara efisien. Struktur data yang berbeda menyediakan cara yang berbeda untuk mengelola dan memanipulasi data, seperti array, linked list, stack, queue, tree, dan graph. Setiap struktur data memiliki karakteristik dan kegunaannya masing-masing, sehingga pemilihan struktur data yang tepat sangat penting untuk efisiensi algoritma dan kinerja program. Pemahaman mendalam tentang struktur data memungkinkan pengembang untuk memilih solusi yang paling efektif untuk masalah tertentu dan mengoptimalkan penggunaan sumber daya komputasi.

## JOBSHEET 2 Array, Pointer dan Stuct

Array adalah kumpulan elemen yang memiliki tipe data yang sama, disusun dalam memori secara berurutan, dan dapat diakses menggunakan indeks. Pointers adalah variabel yang menyimpan alamat memori dari variabel lain, memungkinkan akses dan manipulasi data secara efisien. Struct adalah tipe data yang memungkinkan pengelompokan variabel dari tipe data yang berbeda di bawah satu nama, memfasilitasi pengelolaan data yang lebih kompleks dan terorganisir.


## JOBSHEET 3 Single Linked List

Single linked list adalah struktur data linear yang terdiri dari simpul-simpul yang saling terhubung melalui referensi atau pointer. Setiap simpul memiliki data dan satu pointer yang menunjuk ke simpul berikutnya dalam urutan linear. Operasi pada single linked list termasuk penambahan, penghapusan, pencarian, dan traversal (penelusuran). Kekurangan dari single linked list adalah bahwa untuk mengakses elemen secara acak, perlu dilakukan traversal dari awal.


Petunjuk tentang cara menginstal atau menyiapkan proyek ini. Termasuk prasyarat jika ada, dan langkah-langkah instalasi yang diperlukan.

## JOBSHEET 4 Doubly Linked List

Doubly linked list adalah struktur data linear di mana setiap elemen disimpan bersama dengan dua tautan atau pointer, yaitu ke elemen sebelumnya dan ke elemen berikutnya dalam urutan. Ini memungkinkan traversal maju dan mundur dengan mudah, namun memerlukan lebih banyak ruang untuk menyimpan pointer tambahan dibandingkan dengan singly linked list.

## JOBSHEET 5 Circular Linked List

Double linked list adalah struktur data linear di mana setiap node memiliki dua pointer, yaitu pointer yang menunjuk ke node sebelumnya (previous) dan pointer yang menunjuk ke node berikutnya (next). Ini memungkinkan traversal maju dan mundur di dalam list dengan mudah, namun membutuhkan lebih banyak ruang untuk menyimpan pointer tambahan.

## JOBSHEET 6 Stack

Stack adalah struktur data yang beroperasi berdasarkan prinsip Last In, First Out (LIFO), di mana elemen terakhir yang dimasukkan adalah elemen pertama yang akan dikeluarkan.

Pus untuk Menambahkan elemen ke bagian atas stack.
Pop untuk Menghapus elemen dari bagian atas stack.
Peek/Top untuk Melihat elemen di bagian atas stack tanpa menghapusnya.
IsEmpty untuk Memeriksa apakah stack kosong.
Stack banyak digunakan dalam berbagai aplikasi, seperti dalam implementasi fungsi rekursif, penanganan ekspresi aritmatika, dan navigasi browser (riwayat halaman).

## JOBSHEET 7 Queue

Queue adalah struktur data linier yang mengikuti prinsip FIFO (First In, First Out), di mana elemen yang pertama kali dimasukkan akan menjadi elemen pertama yang dikeluarkan. Queue digunakan untuk mengatur antrian dalam berbagai konteks, seperti pemrosesan tugas dalam sistem operasi, penjadwalan tugas, dan manajemen data dalam jaringan. Operasi utama dalam queue meliputi enqueue (menambahkan elemen ke belakang antrian) dan dequeue (menghapus elemen dari depan antrian). Queue dapat diimplementasikan menggunakan array, linked list, atau struktur data lainnya.

## JOBSHEET 8 Bubble and Insertion Sort

Bubble Sort dan Insertion Sort adalah algoritma pengurutan dasar yang digunakan untuk menyusun elemen-elemen dalam suatu list. Bubble Sort bekerja dengan cara membandingkan setiap pasangan elemen yang berdekatan dan menukarnya jika mereka berada dalam urutan yang salah, proses ini diulang terus menerus hingga tidak ada lagi elemen yang perlu ditukar. Sementara itu, Insertion Sort mengurutkan elemen-elemen dengan cara membagi list menjadi dua bagian: bagian yang sudah diurutkan dan bagian yang belum diurutkan. Elemen dari bagian yang belum diurutkan diambil satu per satu dan ditempatkan pada posisi yang tepat dalam bagian yang sudah diurutkan. Kedua algoritma ini sederhana dan mudah diimplementasikan, tetapi kurang efisien untuk list yang besar karena kompleksitas waktu yang tinggi, yaitu O(n^2). Meskipun demikian, Insertion Sort sering kali lebih cepat daripada Bubble Sort untuk list yang hampir terurut.

## JOBSHEET 9 Selection and Merge Sort

Selection sort dan merge sort adalah dua algoritma pengurutan dengan pendekatan yang berbeda. Selection sort bekerja dengan cara memilih elemen terkecil dari daftar yang belum terurut dan menukarnya dengan elemen pertama dari daftar tersebut, kemudian melanjutkan proses ini untuk elemen kedua, ketiga, dan seterusnya sampai daftar terurut sepenuhnya. Algoritma ini sederhana tetapi memiliki kompleksitas waktu O(n^2), sehingga kurang efisien untuk daftar yang besar.

Merge sort, di sisi lain, adalah algoritma pengurutan berbasis divide-and-conquer. Algoritma ini membagi daftar menjadi dua bagian, mengurutkan masing-masing bagian secara rekursif, dan kemudian menggabungkannya kembali menjadi daftar yang terurut. Merge sort lebih efisien dengan kompleksitas waktu O(n log n) dan kinerja yang konsisten, menjadikannya pilihan yang baik untuk daftar yang besar.

## JOBSHEET 10 Shell and Quick Sort 

Shell sort adalah algoritma pengurutan yang mengembangkan bubble sort dengan menggunakan gap yang mengecil secara bertahap untuk melakukan pengurutan sebagian elemen sebelum melakukan pengurutan secara penuh. Metode ini efektif mengurangi jumlah pertukaran yang diperlukan, meningkatkan efisiensi pada data yang hampir terurut.

Quick sort adalah algoritma pengurutan yang menggunakan strategi divide and conquer, dengan memilih elemen pivot dan membagi array menjadi dua sub-array, lalu mengurutkan sub-array tersebut secara rekursif. Quick sort terkenal karena efisiensinya pada kebanyakan kasus, meskipun kinerjanya bisa menurun pada data yang sudah terurut atau memiliki banyak elemen duplikat jika tidak diimplementasikan dengan baik.

## JOBSHEET 11 Linear and Binary Search

Linear search adalah metode pencarian data yang sederhana di mana setiap elemen dalam daftar diperiksa satu per satu hingga elemen yang dicari ditemukan atau seluruh daftar telah diperiksa. Metode ini efisien untuk daftar kecil atau jika elemen yang dicari berada di awal daftar, tetapi menjadi tidak efisien untuk daftar besar karena waktu pencariannya bersifat linier.

Binary search adalah metode pencarian yang lebih efisien untuk daftar yang sudah terurut. Metode ini bekerja dengan membagi daftar menjadi dua bagian secara berulang, membandingkan elemen tengah dengan elemen yang dicari. Jika elemen yang dicari lebih kecil dari elemen tengah, pencarian dilanjutkan pada bagian kiri daftar, sebaliknya pada bagian kanan jika lebih besar. Proses ini terus diulangi hingga elemen ditemukan atau daftar tidak bisa dibagi lagi. Binary search jauh lebih efisien daripada linear search untuk daftar besar karena waktu pencariannya bersifat logaritmik.


## JOBSHEET 12 Tree

Tree dalam struktur data adalah struktur hierarkis yang terdiri dari node-node yang saling terhubung dengan hubungan induk-anak. Setiap tree memiliki satu node utama yang disebut root, dan setiap node dapat memiliki sejumlah node anak. Node tanpa anak disebut daun. Tree digunakan untuk merepresentasikan data yang memiliki hubungan hierarkis, seperti file sistem, struktur organisasi, dan ekspresi matematika. Beberapa jenis tree yang umum adalah binary tree, binary search tree, AVL tree, dan B-tree, masing-masing dengan karakteristik dan kegunaan spesifik. Tree memungkinkan operasi pencarian, penyisipan, dan penghapusan dilakukan dengan efisien.


## JOBSHEET 13 Graphs

Graphs dalam struktur data adalah representasi abstrak dari hubungan antara objek-objek. Mereka terdiri dari simpul (nodes) dan tepi (edges) yang menghubungkan simpul-simpul tersebut. Graphs dapat diarahkan (directed) atau tidak diarahkan (undirected). Mereka digunakan untuk memodelkan berbagai masalah seperti jaringan sosial, jaringan komputer, dan rute transportasi. Beberapa algoritma umum yang digunakan pada graphs termasuk BFS (Breadth-First Search), DFS (Depth-First Search), dan algoritma Dijkstra untuk menemukan jalur terpendek. Struktur data graph sangat penting dalam ilmu komputer karena kemampuannya untuk menangani dan memodelkan hubungan kompleks antara data.



### Opsional: Pengakuan

Jika ada pihak-pihak yang kamu ingin berterima kasih atas kontribusinya pada proyek ini, kamu bisa menyertakan bagian pengakuan di bagian akhir README.











































